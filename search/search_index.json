{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documenta\u00e7\u00e3o LabVirtual","text":"<p>Link do PyPi.</p> <p>Compartilhamos aqui alguns conte\u00fados que estamos desenvolvendo buscando formatar um laborat\u00f3rio virtual para sistemas din\u00e2micos e controle na Faculdade de Engenharia El\u00e9trica da UFPA-Tucuru\u00ed.</p>"},{"location":"#instalacao-da-biblioteca","title":"Instala\u00e7\u00e3o da Biblioteca","text":""},{"location":"#como-instalar","title":"Como Instalar?","text":"<p>Para instalar o LabVirtual voc\u00ea pode usar o pip, conda ou o poetry.</p> <p>A biblioteca est\u00e1 dispon\u00edvel para ser instalada via o gerenciador de pacotes do python, para instalar basta digitar o comando abaixo em seu terminal.</p>"},{"location":"#instalacao-com-o-pip","title":"Instala\u00e7\u00e3o com o pip","text":"<pre><code>pip install labvirtual\n</code></pre>"},{"location":"#instalacao-com-o-conda","title":"Instala\u00e7\u00e3o com o conda","text":"<pre><code>conda install labvirtual\n</code></pre>"},{"location":"#instalacao-com-o-poetry","title":"Instala\u00e7\u00e3o com o poetry","text":"<pre><code>poetry add labvirtual\n</code></pre>"},{"location":"#sistemas-de-interesse","title":"Sistemas de interesse:","text":"<p>Sistemas poss\u00edveis: - 1 - Maglev - 4 - Aerop\u00eandulo</p>"},{"location":"#introducao","title":"Introdu\u00e7\u00e3o","text":""},{"location":"#exemplo-de-uso","title":"Exemplo de uso:","text":""},{"location":"#exemplo-maglev","title":"Exemplo Maglev","text":"<pre><code># -----------------------------------------------------\n# Universidade Federal do Par\u00e1\n# Campus Universit\u00e1rio de Tucuru\u00ed\n# Faculdade de Engenharia El\u00e9trica\n# -----------------------------------------------------\n#\n# Laborat\u00f3rio Virtual Sistemas Din\u00e2micos e Controle\n# Simulador: Maglev\n# Autor: Yuri Cota\n# Orientadores: Prof. Dr: Raphael Teixeira,\n#               Prof. Dr: Rafael Bayma\n#\n# Data: 2023\n#  ----------------------------------------------------\n#\n# Bibliotecas\nimport time\n\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport vpython as vp\n\n# Importando o Modelo Matem\u00e1tico do Maglev\nfrom labvirtual.simulador_maglev import Maglev\n\n# Importando o Compensador\nfrom labvirtual.simulador_maglev import Compensador\n\n# Importando Simulador e Gr\u00e1fico\nfrom labvirtual.simulador_maglev import Simulacao\nfrom labvirtual.simulador_maglev import Grafico\n\n\ndef run_maglev():\n    # Cria\u00e7\u00e3o dos objetos da planta e controlador para simular\n    mag = Maglev(m=29e-3, k=9.55e-6, mu=2.19e-3, I0=1)\n    comp = Compensador(mag, [-3*mag.lamda]*3, [-8*mag.lamda]*2)\n\n    # Criando um Objeto Simulacao\n    sim = Simulacao(mag_x0=mag.x0)\n\n    grafico = Grafico()\n\n    # Definindo os sinais de refer\u00eancia para rastreamento\n    def ref_seno(t):\n        return (mag.x0*np.sin(2*vp.pi*t))\n\n    def ref_quad(t):\n        return (mag.x0)*(np.sin(2*vp.pi*t) &gt;= 0)\n\n    # Fun\u00e7\u00e3o para ajustar coordenadas do modelo \u00e0s coordenadas do VPython\n    def converte_posicao(y_maglev):\n        return (sim.bobina_3.pos + vp.vec(0, -y_maglev, 0))*4\n\n    # Fun\u00e7\u00e3o para implementar ru\u00eddo gaussiano\n    def ruido(amp):\n        return amp*np.random.normal(loc=0, scale=amp)\n\n    # LOOP -------------------------------------------------------------------\n    # Criando o loop da simula\u00e7\u00e3o\n    while True:\n        vp.rate(sim.fps)\n        # Verifica\u00e7\u00e3o da posi\u00e7\u00e3o do cilindro antes de executar o programa\n        if sim.cil.pos == vp.vector(12e-2, -3.5e-2, 0):\n            grafico.legenda_1.text = \"&lt;b&gt;O cilindro est\u00e1 na posi\u00e7\u00e3o inicial!&lt;/b&gt;\"\n            grafico.legenda_1.color = vp.color.green\n        elif sim.cil.pos == vp.vector(0, 0, 0):\n            grafico.legenda_1.text = \"&lt;b&gt;Cilindo grudado!&lt;/b&gt;\"\n            grafico.legenda_1.color = vp.color.red\n        elif sim.cil.pos.y &lt;= 0 and sim.cil.pos.y &gt;= -0.08 and sim.cil.pos.x == 0:\n            grafico.legenda_1.text = \"&lt;b&gt;O cilindro est\u00e1 na regi\u00e3o de equil\u00edbrio!&lt;/b&gt;\"\n            grafico.legenda_1.color = vp.color.cyan\n        else:\n            grafico.legenda_1.text = \"&lt;b&gt;O cilindro est\u00e1 fora da regi\u00e3o de equil\u00edbrio!&lt;/b&gt;\"\n            grafico.legenda_1.color = vp.color.purple\n\n        # Acionando o bot\u00e3o executar\n        if sim.executar:\n            # O primeiro caso: se o cilindro est\u00e1 na posi\u00e7\u00e3o inicial o\n            # programa n\u00e3o vai sair da tela inicial.\n            if sim.cil.pos == vp.vector(12e-2, -3.5e-2, 0):\n                sim.cil.pos = vp.vector(12e-2, -3.5e-2, 0)\n                grafico.yplot.delete()\n                grafico.rplot.delete()\n                sim.t = 0\n                # time.sleep(2)\n                sim.executar = not sim.executar\n                sim.bt1_exe.text = \"Executar\"\n\n            #  O segundo caso: o cilindro est\u00e1 grudado no eletroim\u00e3,\n            # tem que aguardar o programa voltar pra tela inicial.\n            elif sim.cil.pos == vp.vector(0, 0, 0):\n                time.sleep(3)\n                sim.executar = not sim.executar\n                sim.bt1_exe.text = \"Executar\"\n                sim.cil.pos = vp.vector(12e-2, -3.5e-2, 0)\n\n            # O terceiro caso: o cilindro est\u00e1 na regi\u00e3o \n            # de equil\u00edbrio, logo o programa ir\u00e1 rodar normalmente.\n            elif sim.cil.pos.y &lt;= 0 and sim.cil.pos.y &gt;= -0.08 and sim.cil.pos.x == 0:\n\n                # Atualiza o sinal de refer\u00eancia para enviar para o solver\n                match sim.M.index:\n                    case 0 | None:\n                        def sinal(t):\n                            return ref_seno(sim.sl.value*sim.t)*(sim.sl2.value)\n                    case 1:\n                        def sinal(t):\n                            return ref_quad(sim.sl.value*sim.t)*(sim.sl2.value)\n\n                # Chama o solver para atualizar os estados do maglev\n                sol = solve_ivp(Maglev.estadosmf, t_span=[\n                                sim.t, sim.t+sim.dt], y0=sim.y,\n                                args=(sinal, mag, comp))\n\n                # Recupera os resultados da simula\u00e7\u00e3o\n                sim.y = sol.y[:, -1]+ruido(1e-6)\n\n                # Atualiza os gr\u00e1ficos\n                grafico.yplot.plot(sim.t, sim.y[0])\n                grafico.rplot.plot(sim.t, sinal(sim.t)+mag.x0)\n                # print(y[0])\n\n                # Atualiza a posi\u00e7\u00e3o do cilindro\n                sim.cil.pos = converte_posicao(sim.y[0])\n\n                # Atualiza o tempo\n                sim.t += sim.dt\n    # O quarto caso: o cilindro est\u00e1 fora da regi\u00e3o de equil\u00edbrio,\n    # logo ele ir\u00e1 cair na mesa e retornar a posi\u00e7\u00e3o inicial.\n            else:\n                while sim.cil.pos.y &gt;= -3.5e-2:\n                    vp.rate(sim.fps)\n                    sim.cil.v = sim.cil.v+sim.g*sim.dt\n                    sim.cil.pos = sim.cil.pos+sim.cil.v*sim.dt\n                    sim.t = sim.t+sim.dt\n                grafico.legenda_1.text = \"&lt;b&gt;Aguarde o cilindro retonar a posi\u00e7\u00e3o incial!&lt;/b&gt;\"\n                grafico.legenda_1.color = vp.color.red\n                time.sleep(4)\n                sim.cil.pos = vp.vector(12e-2, -3.5e-2, 0)\n                print(sim.t)\n\n\nif __name__ == \"__main__\":\n    run_maglev()\n</code></pre>"},{"location":"#exemplo-aeropendulo","title":"Exemplo Aerop\u00eandulo","text":"<pre><code># -----------------------------------------------------\n# Universidade Federal do Par\u00e1\n# Campus Universit\u00e1rio de Tucuru\u00ed\n# Faculdade de Engenharia El\u00e9trica\n# -----------------------------------------------------\n#\n# Laborat\u00f3rio Virtual Sistemas Din\u00e2micos e Controle\n# Simulador: Aerop\u00eandulo\n# Autor: Os\u00e9ias Farias\n# Orientadores: Prof. Dr: Raphael Teixeira,\n#               Prof. Dr: Rafael Bayma\n#\n# Data: 2023\n#  ----------------------------------------------------\n#\n\nimport vpython as vp\nimport numpy as np\nfrom labvirtual.simulador_aeropendulo import (Graficos, AnimacaoAeropendulo,\n                                              Interface, ModeloMatAeropendulo,\n                                              ControladorDiscreto)\n\n\ndef run_aeropendulo():\n    # Instanciando um objeto AeropenduloAaeropendulo()\n    animacao_aeropendulo = AnimacaoAeropendulo()\n\n    # Instanciando um objeto para plotagem dos gr\u00e1ficos din\u00e2micos dos\n    # estados do Aerop\u00eandulo\n    g = Graficos()\n    graf, plot1, plot2, plot3, plot4 = g.graficos()\n\n    # Inst\u00e2nciando um objeto para solu\u00e7\u00e3o matem\u00e1tica do sistema Aerop\u00eandulo.\n    Km = 0.0296\n    m = 0.36\n    d = 0.03\n    J = 0.0106\n    c = 0.0076\n    mma = ModeloMatAeropendulo(K_m=Km, m=m, d=d, J=J, c=c)\n\n    # Inst\u00e2nciando um objeto ControladorDiscreto\n    controlador = ControladorDiscreto(referencia=0.01)\n    u = 0  # Sinal de controle inicial\n\n    # Instanciando um objeto Interface\n    interface = Interface(animacao_aeropendulo, controlador)\n\n    ts = 1e-2\n    # Condi\u00e7\u00f5es Iniciais dos estados\n    x = np.array([0.0, 0.0])\n    t = 0.0\n    t_ant = 0.0\n\n    # Simula\u00e7\u00e3o do Sistema\n    while True:\n        vp.rate(100)\n        if interface.EXE:\n            # Calcula as derivadas do sitema\n            dx = mma.modelo_aeropendulo(x, t)\n            dt = t - t_ant\n\n            # Atualiza\u00e7\u00e3o dos estados\n            x = x + dt * dx\n\n            # Pega o \u00c2ngulo e envia para o controlador\n            # (Realimenta\u00e7\u00e3o do sistema)\n            controlador.set_sensor(x[1])\n\n            # O controlador calcula o sinal de controle\n            controlador.control_pi()\n\n            # Controle proporcional\n            # controlador.controle_proporcional(kp=10.0)\n            # pega o sinal de controle calculado e salva na vari\u00e1vel u\n            u = controlador.get_u()\n\n            # Sinal de controle aplicado a entrada do sistema\n            mma.set_u(u)\n\n            # print(x[1]*(180/np.pi))\n            t_ant = t\n            t += ts\n\n            # Atualiza o \u00e2ngulo do Aerop\u00eandulo\n            animacao_aeropendulo.aeropendulo.rotate(axis=vp.vec(0, 0, 1),\n                                                    angle=x[0]*ts,\n                                                    origin=vp.vec(0, 5.2, 0))\n\n            # Anima\u00e7\u00e3o da din\u00e2mica da H\u00e9lice\n            animacao_aeropendulo.update_helice(x[0], ts)\n\n            # print(x[1] + interface.valor_angle)\n            # Gr\u00e1fico do \u00e2ngulo.\n            plot1.plot(t, x[1] + interface.valor_angle)\n            # Gr\u00e1fico do sinal de refer\u00eancia\n            plot2.plot(t, controlador.r + interface.valor_angle)\n            # Gr\u00e1fico da velocidade \u00e2ngular.\n            plot3.plot(t, x[0])\n            # Gr\u00e1fico do sinal de controle\n            plot4.plot(t, u)\n\n\nif __name__ == \"__main__\":\n    run_aeropendulo()\n</code></pre>"},{"location":"animacao_aeropendulo_reference/","title":"Docs M\u00f3dulo animacao_aeropendulo","text":""},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo","title":"<code>labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo</code>","text":"<p>Classe que implementa a amina\u00e7\u00e3o do Aerop\u00eandulo.</p> Atributo <p>comprimento_braco: tamanho do bra\u00e7o do Aerop\u00eandulo.</p> Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>class AnimacaoAeropendulo:\n\"\"\"\n    Classe que implementa a amina\u00e7\u00e3o do Aerop\u00eandulo.\n\n    Atributo:\n        comprimento_braco: tamanho do bra\u00e7o do Aerop\u00eandulo.\n    \"\"\"\n    def __init__(self, comprimento_braco=4.4) -&gt; None:\n        # Par\u00e2metros do Aerop\u00eandulo\n        self.comprimento_braco = comprimento_braco\n        self.scene = vp.canvas(title=\"&lt;center&gt;&lt;h1&gt;Aerop\u00eandulo&lt;/h1&gt;&lt;center/&gt;\",\n                               width=650,\n                               height=580, align=\"left\", autoscale=0, range=5,\n                               center=vp.vec(0, 3, 0),\n                               background=vp.vector(1.7, 0.7, 0.9),\n                               color=vp.vec(1, 0.6, 0.6),\n                               forward=vp.vec(-0.3, 0, -1))\n        self.scene.range = 6\n        # chamando a fun\u00e7\u00e3o para criar a amina\u00e7\u00e3o gr\u00e1fica do Aerop\u00eandulo.\n        self.aeropendulo = self.__aminacao()\n        self.__helice()\n\n    def __aminacao(self) -&gt; vp.compound:\n\"\"\"\n        Classe que implementa o Aerop\u00eandulo.\n\n        Args:\n            comprimento_braco: tamanho do bra\u00e7o do Aerop\u00eandulo.\n        Returns:\n            Retorna um objeto (vpython) que cont\u00eam a estrutura do Aerop\u00eandulo.\n        \"\"\"\n        self.base = vp.box(pos=vp.vec(0, -0.85, 0), size=vp.vec(30, 0.2, 15),\n                           texture=vp.textures.wood)\n        self.parede = vp.box(pos=vp.vec(0, 7.1, -7.55),\n                             size=vp.vec(30, 16, 0.2),\n                             color=vp.vec(0.1, 0.1, 0.1), shininess=0.01)\n        self.sitio = vp.text(pos=vp.vec(0, 8.1, -7.45),\n                             text=\"AEROP\u00caNDULO\", color=vp.vec(1, 0.6, 0.6),\n                             align='center', depth=0)\n\n        self.__desenhar_pendulo()\n\n        # Eixo de sustenta\u00e7\u00e3o.\n        self.eixo = vp.cylinder(pos=vp.vec(0, 5.2, 0.3), radius=0.09,\n                                axis=vp.vec(0, 0, -2),\n                                color=vp.vec(0.7, 0.4, 0.1))\n\n        # Estrutura de sustenta\u00e7\u00e3o do aerop\u00eandulo.\n        self.b1 = vp.box(pos=vp.vec(0, 1.7, -2), size=vp.vec(3, 8, 0.6),\n                         color=vp.vec(0.8, 0.8, 0.8))\n\n        self.b2 = vp.box(pos=vp.vec(0, -0.6, -1.5), size=vp.vec(4.5, 0.4, 2.5),\n                         color=vp.vec(0.8, 0.8, 0.8))\n\n        self.logo = vp.box(pos=vp.vec(0, 2.5, -1.799),\n                           texture=\"https://i.imgur.com/D2xnkpF.png\",\n                           size=vp.vec(2, 2, 0.2))\n\n        self.ufpa = vp.text(pos=vp.vec(0, 3.7, -1.7), text=\"UFPA\",\n                            color=vp.vec(1, 0.6, 0.6), height=0.5,\n                            align='center', depth=0)\n\n        return self.pendulo\n\n    def __helice(self) -&gt; None:\n        self.helice = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                             size=vp.vec(0.05, 0.2, 2),\n                             color=vp.vec(1, 1, 0))\n\n        self.helice1 = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                              size=vp.vec(0.05, 0.2, 2),\n                              color=vp.vec(1, 1, 0))\n        self.helice1.axis = self.pendulo.axis\n        self.helice1.size = vp.vec(0.05, 0.2, 2)\n        self.helice1.rotate(axis=vp.vec(1, 0, 0),\n                            angle=vp.pi/4)\n\n        self.helice2 = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                              size=vp.vec(0.05, 0.2, 2),\n                              color=vp.vec(1, 1, 0))\n        self.helice2.axis = self.pendulo.axis\n        self.helice2.size = vp.vec(0.05, 0.2, 2)\n        self.helice2.rotate(axis=vp.vec(1, 0, 0),\n                            angle=vp.pi/2)\n\n        self.helice3 = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                              size=vp.vec(0.05, 0.2, 2),\n                              color=vp.vec(1, 1, 0))\n        self.helice3.axis = self.pendulo.axis\n        self.helice3.size = vp.vec(0.05, 0.2, 2)\n        self.helice3.rotate(axis=vp.vec(1, 0, 0),\n                            angle=3*vp.pi/4.)\n        self.helice1.visible = False\n        self.helice2.visible = False\n        self.helice3.visible = False\n\n    def pause_giro(self) -&gt; None:\n        self.helice1.visible = True\n        self.helice2.visible = True\n        self.helice3.visible = True\n\n    def girar_helice(self) -&gt; None:\n        self.helice1.visible = False\n        self.helice2.visible = False\n        self.helice3.visible = False\n\n    def set_posicao_helice(self, angle):\n        self.helice.rotate(axis=vp.vec(0, 0, 1),\n                           angle=angle,\n                           origin=vp.vec(0, 5.2, 0))\n        self.helice.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice1.rotate(axis=vp.vec(0, 0, 1),\n                            angle=angle,\n                            origin=vp.vec(0, 5.2, 0))\n        self.helice1.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice2.rotate(axis=vp.vec(0, 0, 1),\n                            angle=angle,\n                            origin=vp.vec(0, 5.2, 0))\n        self.helice2.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice3.rotate(axis=vp.vec(0, 0, 1),\n                            angle=angle,\n                            origin=vp.vec(0, 5.2, 0))\n        self.helice3.size = vp.vec(0.05, 0.2, 2)\n\n    def update_helice(self, angle, ts) -&gt; None:\n\n        self.helice.size = vp.vec(0.05, 0.2, 2)\n        self.helice1.size = vp.vec(0.05, 0.2, 2)\n        self.helice2.size = vp.vec(0.05, 0.2, 2)\n        self.helice3.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice.axis = self.pendulo.axis\n        self.helice.size = vp.vec(0.05, 0.2, 2)\n        self.helice1.axis = self.pendulo.axis\n        self.helice1.size = vp.vec(0.05, 0.2, 2)\n        self.helice2.axis = self.pendulo.axis\n        self.helice2.size = vp.vec(0.05, 0.2, 2)\n        self.helice3.axis = self.pendulo.axis\n        self.helice3.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice.rotate(axis=vp.vec(0, 0, 1),\n                           angle=angle*ts,\n                           origin=vp.vec(0, 5.2, 0))\n        self.helice.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice1.rotate(axis=vp.vec(0, 0, 1),\n                            angle=angle*ts,\n                            origin=vp.vec(0, 5.2, 0))\n        self.helice1.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice2.rotate(axis=vp.vec(0, 0, 1),\n                            angle=angle*ts,\n                            origin=vp.vec(0, 5.2, 0))\n        self.helice2.size = vp.vec(0.05, 0.2, 2)\n\n        self.helice3.rotate(axis=vp.vec(0, 0, 1),\n                            angle=angle*ts,\n                            origin=vp.vec(0, 5.2, 0))\n        self.helice3.size = vp.vec(0.05, 0.2, 2)\n\n        # obs tentando ajustar o diro das h\u00e9lices apenas para um lado ....\n        # if x[1] + interface.valor_angle &lt; np.pi/2:\n        #     ag = 0.3\n        # else:\n        #     ag = -0.8\n\n        self.helice.rotate(axis=vp.vec(1, 0,  0), angle=0.09)\n        self.helice1.rotate(axis=vp.vec(1, 0, 0), angle=0.09)\n        self.helice2.rotate(axis=vp.vec(1, 0, 0), angle=0.09)\n        self.helice3.rotate(axis=vp.vec(1, 0, 0), angle=0.09)\n\n    def __desenhar_pendulo(self) -&gt; None:\n        # Bra\u00e7o do Aerop\u00eandulo.\n        self.barra = vp.box(pos=vp.vec(0, -1.4, 0),\n                            size=vp.vec(0.2, self.comprimento_braco, 0.2),\n                            color=vp.vec(0.5, 0.5, 0.95))\n\n        # Base que acopla o motor ao bra\u00e7o.\n        self.base_motor = vp.cylinder(pos=vp.vec(-0.2, -4, 0), radius=0.4,\n                                      axis=vp.vec(0.4, 0, 0),\n                                      color=vp.vec(0.5, 0.5, 0.95))\n        # Armadura do motor.\n        self.base2_motor = vp.box(pos=vp.vec(0.4, -4, 0),\n                                  size=vp.vec(0.4, 0.4, 0.4),\n                                  color=vp.vec(1, 1, 0))\n\n        # Eixo que da h\u00e9lice do motor\n        self.base_helice = vp.cylinder(pos=vp.vec(0.4, -4, 0), radius=0.05,\n                                       axis=vp.vec(0.4, 0, 0),\n                                       color=vp.vec(0.5, 0.5, 0.8))\n\n        # Motor completo.\n        self.motor = vp.compound([self.base_motor,\n                                  self.base2_motor,\n                                  self.base_helice])\n\n        # Aerop\u00eandulo\n        self.pendulo = vp.compound([self.barra, self.motor])\n        self.pendulo.pos = vp.vec(0.31, 2.7, 0)\n</code></pre>"},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo.__aminacao","title":"<code>__aminacao()</code>","text":"<p>Classe que implementa o Aerop\u00eandulo.</p> <p>Parameters:</p> Name Type Description Default <code>comprimento_braco</code> <p>tamanho do bra\u00e7o do Aerop\u00eandulo.</p> required <p>Returns:</p> Type Description <code>vp.compound</code> <p>Retorna um objeto (vpython) que cont\u00eam a estrutura do Aerop\u00eandulo.</p> Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>def __aminacao(self) -&gt; vp.compound:\n\"\"\"\n    Classe que implementa o Aerop\u00eandulo.\n\n    Args:\n        comprimento_braco: tamanho do bra\u00e7o do Aerop\u00eandulo.\n    Returns:\n        Retorna um objeto (vpython) que cont\u00eam a estrutura do Aerop\u00eandulo.\n    \"\"\"\n    self.base = vp.box(pos=vp.vec(0, -0.85, 0), size=vp.vec(30, 0.2, 15),\n                       texture=vp.textures.wood)\n    self.parede = vp.box(pos=vp.vec(0, 7.1, -7.55),\n                         size=vp.vec(30, 16, 0.2),\n                         color=vp.vec(0.1, 0.1, 0.1), shininess=0.01)\n    self.sitio = vp.text(pos=vp.vec(0, 8.1, -7.45),\n                         text=\"AEROP\u00caNDULO\", color=vp.vec(1, 0.6, 0.6),\n                         align='center', depth=0)\n\n    self.__desenhar_pendulo()\n\n    # Eixo de sustenta\u00e7\u00e3o.\n    self.eixo = vp.cylinder(pos=vp.vec(0, 5.2, 0.3), radius=0.09,\n                            axis=vp.vec(0, 0, -2),\n                            color=vp.vec(0.7, 0.4, 0.1))\n\n    # Estrutura de sustenta\u00e7\u00e3o do aerop\u00eandulo.\n    self.b1 = vp.box(pos=vp.vec(0, 1.7, -2), size=vp.vec(3, 8, 0.6),\n                     color=vp.vec(0.8, 0.8, 0.8))\n\n    self.b2 = vp.box(pos=vp.vec(0, -0.6, -1.5), size=vp.vec(4.5, 0.4, 2.5),\n                     color=vp.vec(0.8, 0.8, 0.8))\n\n    self.logo = vp.box(pos=vp.vec(0, 2.5, -1.799),\n                       texture=\"https://i.imgur.com/D2xnkpF.png\",\n                       size=vp.vec(2, 2, 0.2))\n\n    self.ufpa = vp.text(pos=vp.vec(0, 3.7, -1.7), text=\"UFPA\",\n                        color=vp.vec(1, 0.6, 0.6), height=0.5,\n                        align='center', depth=0)\n\n    return self.pendulo\n</code></pre>"},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo.__helice","title":"<code>__helice()</code>","text":"Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>def __helice(self) -&gt; None:\n    self.helice = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                         size=vp.vec(0.05, 0.2, 2),\n                         color=vp.vec(1, 1, 0))\n\n    self.helice1 = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                          size=vp.vec(0.05, 0.2, 2),\n                          color=vp.vec(1, 1, 0))\n    self.helice1.axis = self.pendulo.axis\n    self.helice1.size = vp.vec(0.05, 0.2, 2)\n    self.helice1.rotate(axis=vp.vec(1, 0, 0),\n                        angle=vp.pi/4)\n\n    self.helice2 = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                          size=vp.vec(0.05, 0.2, 2),\n                          color=vp.vec(1, 1, 0))\n    self.helice2.axis = self.pendulo.axis\n    self.helice2.size = vp.vec(0.05, 0.2, 2)\n    self.helice2.rotate(axis=vp.vec(1, 0, 0),\n                        angle=vp.pi/2)\n\n    self.helice3 = vp.box(pos=vp.vec(0.8, 0.6, 0),\n                          size=vp.vec(0.05, 0.2, 2),\n                          color=vp.vec(1, 1, 0))\n    self.helice3.axis = self.pendulo.axis\n    self.helice3.size = vp.vec(0.05, 0.2, 2)\n    self.helice3.rotate(axis=vp.vec(1, 0, 0),\n                        angle=3*vp.pi/4.)\n    self.helice1.visible = False\n    self.helice2.visible = False\n    self.helice3.visible = False\n</code></pre>"},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo.pause_giro","title":"<code>pause_giro()</code>","text":"Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>def pause_giro(self) -&gt; None:\n    self.helice1.visible = True\n    self.helice2.visible = True\n    self.helice3.visible = True\n</code></pre>"},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo.girar_helice","title":"<code>girar_helice()</code>","text":"Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>def girar_helice(self) -&gt; None:\n    self.helice1.visible = False\n    self.helice2.visible = False\n    self.helice3.visible = False\n</code></pre>"},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo.set_posicao_helice","title":"<code>set_posicao_helice(angle)</code>","text":"Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>def set_posicao_helice(self, angle):\n    self.helice.rotate(axis=vp.vec(0, 0, 1),\n                       angle=angle,\n                       origin=vp.vec(0, 5.2, 0))\n    self.helice.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice1.rotate(axis=vp.vec(0, 0, 1),\n                        angle=angle,\n                        origin=vp.vec(0, 5.2, 0))\n    self.helice1.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice2.rotate(axis=vp.vec(0, 0, 1),\n                        angle=angle,\n                        origin=vp.vec(0, 5.2, 0))\n    self.helice2.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice3.rotate(axis=vp.vec(0, 0, 1),\n                        angle=angle,\n                        origin=vp.vec(0, 5.2, 0))\n    self.helice3.size = vp.vec(0.05, 0.2, 2)\n</code></pre>"},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo.update_helice","title":"<code>update_helice(angle, ts)</code>","text":"Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>def update_helice(self, angle, ts) -&gt; None:\n\n    self.helice.size = vp.vec(0.05, 0.2, 2)\n    self.helice1.size = vp.vec(0.05, 0.2, 2)\n    self.helice2.size = vp.vec(0.05, 0.2, 2)\n    self.helice3.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice.axis = self.pendulo.axis\n    self.helice.size = vp.vec(0.05, 0.2, 2)\n    self.helice1.axis = self.pendulo.axis\n    self.helice1.size = vp.vec(0.05, 0.2, 2)\n    self.helice2.axis = self.pendulo.axis\n    self.helice2.size = vp.vec(0.05, 0.2, 2)\n    self.helice3.axis = self.pendulo.axis\n    self.helice3.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice.rotate(axis=vp.vec(0, 0, 1),\n                       angle=angle*ts,\n                       origin=vp.vec(0, 5.2, 0))\n    self.helice.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice1.rotate(axis=vp.vec(0, 0, 1),\n                        angle=angle*ts,\n                        origin=vp.vec(0, 5.2, 0))\n    self.helice1.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice2.rotate(axis=vp.vec(0, 0, 1),\n                        angle=angle*ts,\n                        origin=vp.vec(0, 5.2, 0))\n    self.helice2.size = vp.vec(0.05, 0.2, 2)\n\n    self.helice3.rotate(axis=vp.vec(0, 0, 1),\n                        angle=angle*ts,\n                        origin=vp.vec(0, 5.2, 0))\n    self.helice3.size = vp.vec(0.05, 0.2, 2)\n\n    # obs tentando ajustar o diro das h\u00e9lices apenas para um lado ....\n    # if x[1] + interface.valor_angle &lt; np.pi/2:\n    #     ag = 0.3\n    # else:\n    #     ag = -0.8\n\n    self.helice.rotate(axis=vp.vec(1, 0,  0), angle=0.09)\n    self.helice1.rotate(axis=vp.vec(1, 0, 0), angle=0.09)\n    self.helice2.rotate(axis=vp.vec(1, 0, 0), angle=0.09)\n    self.helice3.rotate(axis=vp.vec(1, 0, 0), angle=0.09)\n</code></pre>"},{"location":"animacao_aeropendulo_reference/#labvirtual.simulador_aeropendulo.animacao_aeropendulo.AnimacaoAeropendulo.__desenhar_pendulo","title":"<code>__desenhar_pendulo()</code>","text":"Source code in <code>labvirtual/simulador_aeropendulo/animacao_aeropendulo.py</code> <pre><code>def __desenhar_pendulo(self) -&gt; None:\n    # Bra\u00e7o do Aerop\u00eandulo.\n    self.barra = vp.box(pos=vp.vec(0, -1.4, 0),\n                        size=vp.vec(0.2, self.comprimento_braco, 0.2),\n                        color=vp.vec(0.5, 0.5, 0.95))\n\n    # Base que acopla o motor ao bra\u00e7o.\n    self.base_motor = vp.cylinder(pos=vp.vec(-0.2, -4, 0), radius=0.4,\n                                  axis=vp.vec(0.4, 0, 0),\n                                  color=vp.vec(0.5, 0.5, 0.95))\n    # Armadura do motor.\n    self.base2_motor = vp.box(pos=vp.vec(0.4, -4, 0),\n                              size=vp.vec(0.4, 0.4, 0.4),\n                              color=vp.vec(1, 1, 0))\n\n    # Eixo que da h\u00e9lice do motor\n    self.base_helice = vp.cylinder(pos=vp.vec(0.4, -4, 0), radius=0.05,\n                                   axis=vp.vec(0.4, 0, 0),\n                                   color=vp.vec(0.5, 0.5, 0.8))\n\n    # Motor completo.\n    self.motor = vp.compound([self.base_motor,\n                              self.base2_motor,\n                              self.base_helice])\n\n    # Aerop\u00eandulo\n    self.pendulo = vp.compound([self.barra, self.motor])\n    self.pendulo.pos = vp.vec(0.31, 2.7, 0)\n</code></pre>"},{"location":"graficos_aeropendulo_reference/","title":"Docs M\u00f3dulo graficos_aeropendulo","text":""},{"location":"graficos_aeropendulo_reference/#labvirtual.simulador_aeropendulo.graficos_aeropendulo.Graficos","title":"<code>labvirtual.simulador_aeropendulo.graficos_aeropendulo.Graficos</code>","text":"<p>Gr\u00e1fico para plotagem dos dados dos estados do Aerop\u00e9ndulo.</p> Source code in <code>labvirtual/simulador_aeropendulo/graficos_aeropendulo.py</code> <pre><code>class Graficos:\n\"\"\"\n    Gr\u00e1fico para plotagem dos dados dos estados do Aerop\u00e9ndulo.\n    \"\"\"\n    def __init__(self, largura: int = 650, altura: int = 400):\n        self.width = largura\n        self.height = altura\n\n    def graficos(self) -&gt; Tuple:\n\"\"\"\n        M\u00e9todo que cria os Gr\u00e1fico.\n\n        Returns:\n            Retorna uma tupla contendo o objeto do gr\u00e1fico e da curvas.\n        \"\"\"\n        titulo = \"Gr\u00e1ficos dos estados do Aerop\u00eandulo\"\n        self.grafico = vp.graph(title=titulo, align=\"right\",\n                                xtitle='tempo (s)', fast=True,\n                                width=self.width, height=self.height,\n                                center=vp.vector(0, 12, 0), scroll=True,\n                                xmin=0, xmax=14, ymin=-0.5, ymax=6, dot=True,\n                                background=vp.vector(0.95, 0.95, 0.95))\n\n        self.curva1 = vp.gcurve(color=vp.color.blue, width=3,\n                                markers=False, label=\"Posi\u00e7\u00e3o Angular (rad)\",\n                                dot=True, dot_color=vp.color.blue)\n\n        self.curva2 = vp.gcurve(color=vp.color.black, width=3, markers=False,\n                                label=\"Refer\u00eancia Angular(rad)\", dot=True,\n                                dot_color=vp.color.black)\n\n        self.curva3 = vp.gcurve(color=vp.color.red, width=3, markers=False,\n                                label=\"Velocidade Angular (rad/s)\", dot=True,\n                                dot_color=vp.color.red)\n\n        self.curva4 = vp.gcurve(color=vp.color.orange, width=3, markers=False,\n                                label=\"Sinal de Controle (V)\", dot=True,\n                                dot_color=vp.color.orange)\n\n        return self.grafico, self.curva1, self.curva2, self.curva3, self.curva4\n</code></pre>"},{"location":"graficos_aeropendulo_reference/#labvirtual.simulador_aeropendulo.graficos_aeropendulo.Graficos.graficos","title":"<code>graficos()</code>","text":"<p>M\u00e9todo que cria os Gr\u00e1fico.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>Retorna uma tupla contendo o objeto do gr\u00e1fico e da curvas.</p> Source code in <code>labvirtual/simulador_aeropendulo/graficos_aeropendulo.py</code> <pre><code>def graficos(self) -&gt; Tuple:\n\"\"\"\n    M\u00e9todo que cria os Gr\u00e1fico.\n\n    Returns:\n        Retorna uma tupla contendo o objeto do gr\u00e1fico e da curvas.\n    \"\"\"\n    titulo = \"Gr\u00e1ficos dos estados do Aerop\u00eandulo\"\n    self.grafico = vp.graph(title=titulo, align=\"right\",\n                            xtitle='tempo (s)', fast=True,\n                            width=self.width, height=self.height,\n                            center=vp.vector(0, 12, 0), scroll=True,\n                            xmin=0, xmax=14, ymin=-0.5, ymax=6, dot=True,\n                            background=vp.vector(0.95, 0.95, 0.95))\n\n    self.curva1 = vp.gcurve(color=vp.color.blue, width=3,\n                            markers=False, label=\"Posi\u00e7\u00e3o Angular (rad)\",\n                            dot=True, dot_color=vp.color.blue)\n\n    self.curva2 = vp.gcurve(color=vp.color.black, width=3, markers=False,\n                            label=\"Refer\u00eancia Angular(rad)\", dot=True,\n                            dot_color=vp.color.black)\n\n    self.curva3 = vp.gcurve(color=vp.color.red, width=3, markers=False,\n                            label=\"Velocidade Angular (rad/s)\", dot=True,\n                            dot_color=vp.color.red)\n\n    self.curva4 = vp.gcurve(color=vp.color.orange, width=3, markers=False,\n                            label=\"Sinal de Controle (V)\", dot=True,\n                            dot_color=vp.color.orange)\n\n    return self.grafico, self.curva1, self.curva2, self.curva3, self.curva4\n</code></pre>"},{"location":"implementacao_controlador_reference/","title":"Docs M\u00f3dulo implementacao_controlador","text":""},{"location":"implementacao_controlador_reference/#labvirtual.simulador_aeropendulo.implementacao_controlador.ControladorDiscreto","title":"<code>labvirtual.simulador_aeropendulo.implementacao_controlador.ControladorDiscreto</code>","text":"<p>Classe que implementa os controladores para o sistema.</p> <p>Parameters:</p> Name Type Description Default <code>referencia</code> <code>int</code> <p>int - Sinal de refer\u00eancia para o controlador seguir.</p> <code>1</code> <code>T</code> <code>float</code> <p>Per\u00edodo de amostragem do controlador.</p> <code>0.0625</code> Return <p>None</p> Source code in <code>labvirtual/simulador_aeropendulo/implementacao_controlador.py</code> <pre><code>class ControladorDiscreto:\n\"\"\"\n        Classe que implementa os controladores para o sistema.\n        Args:\n            referencia: int - Sinal de refer\u00eancia para o controlador seguir.\n            T: Per\u00edodo de amostragem do controlador.\n        Return:\n            None\n    \"\"\"\n    def __init__(self, referencia: int = 1, T: float = 0.0625) -&gt; None:\n        self.uk = 0\n        self.uk1 = 0\n        self.ek = 0\n        self.ek1 = 0\n        self.yout = 0\n        self.k = 0\n        self.r = referencia\n        self.T = T\n\n    # Pega o sinal do sensor\n    def set_sensor(self, yout: float = 1) -&gt; None:\n\"\"\"\n            Recebe o sinal de sa\u00edda, o \u00e2ngulo do bra\u00e7o do aerop\u00eandulo.\n        Args:\n            yout: Sinal do sensor de \u00e2ngulo.\n        Return:\n            None\n        \"\"\"\n        self.yout = yout\n\n    # disponibiliza o sinal de controle\n    def get_u(self) -&gt; float:\n\"\"\"\n            M\u00e9todo que retorna o sinal de controle.\n        Return:\n            float: Sinal de controle.\n        \"\"\"\n        return self.uk\n\n    # Calcula o sinal de controle Proporcional Integral.\n    def control_pi(self) -&gt; None:\n\"\"\"\n            M\u00e9todo que implementa o controle Proporcional Integral\n            discretizado.\n        Return:\n            None\n        \"\"\"\n        self.ek = self.r - self.yout\n        self.uk = self.uk1 + 0.2165 * self.ek - 0.2087 * self.ek1\n        self.ek1 = self.ek\n        self.uk1 = self.uk\n        self.k = self.k + 1\n\n    def controle_proporcional(self, kp=1.0):\n\"\"\"\n            M\u00e9todo que implementa o controle Proporcional discretizado.\n        Args:\n            kp: Ganho do controlador Proporcional.\n        Return:\n            None\n        \"\"\"\n        self.ek = self.r - self.yout\n        self.KP = kp\n        self.uk = self.KP * self.ek\n</code></pre>"},{"location":"implementacao_controlador_reference/#labvirtual.simulador_aeropendulo.implementacao_controlador.ControladorDiscreto.set_sensor","title":"<code>set_sensor(yout=1)</code>","text":"<pre><code>Recebe o sinal de sa\u00edda, o \u00e2ngulo do bra\u00e7o do aerop\u00eandulo.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>yout</code> <code>float</code> <p>Sinal do sensor de \u00e2ngulo.</p> <code>1</code> Return <p>None</p> Source code in <code>labvirtual/simulador_aeropendulo/implementacao_controlador.py</code> <pre><code>def set_sensor(self, yout: float = 1) -&gt; None:\n\"\"\"\n        Recebe o sinal de sa\u00edda, o \u00e2ngulo do bra\u00e7o do aerop\u00eandulo.\n    Args:\n        yout: Sinal do sensor de \u00e2ngulo.\n    Return:\n        None\n    \"\"\"\n    self.yout = yout\n</code></pre>"},{"location":"implementacao_controlador_reference/#labvirtual.simulador_aeropendulo.implementacao_controlador.ControladorDiscreto.get_u","title":"<code>get_u()</code>","text":"<pre><code>M\u00e9todo que retorna o sinal de controle.\n</code></pre> Return <p>float: Sinal de controle.</p> Source code in <code>labvirtual/simulador_aeropendulo/implementacao_controlador.py</code> <pre><code>def get_u(self) -&gt; float:\n\"\"\"\n        M\u00e9todo que retorna o sinal de controle.\n    Return:\n        float: Sinal de controle.\n    \"\"\"\n    return self.uk\n</code></pre>"},{"location":"implementacao_controlador_reference/#labvirtual.simulador_aeropendulo.implementacao_controlador.ControladorDiscreto.control_pi","title":"<code>control_pi()</code>","text":"<pre><code>M\u00e9todo que implementa o controle Proporcional Integral\ndiscretizado.\n</code></pre> Return <p>None</p> Source code in <code>labvirtual/simulador_aeropendulo/implementacao_controlador.py</code> <pre><code>def control_pi(self) -&gt; None:\n\"\"\"\n        M\u00e9todo que implementa o controle Proporcional Integral\n        discretizado.\n    Return:\n        None\n    \"\"\"\n    self.ek = self.r - self.yout\n    self.uk = self.uk1 + 0.2165 * self.ek - 0.2087 * self.ek1\n    self.ek1 = self.ek\n    self.uk1 = self.uk\n    self.k = self.k + 1\n</code></pre>"},{"location":"implementacao_controlador_reference/#labvirtual.simulador_aeropendulo.implementacao_controlador.ControladorDiscreto.controle_proporcional","title":"<code>controle_proporcional(kp=1.0)</code>","text":"<pre><code>M\u00e9todo que implementa o controle Proporcional discretizado.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>kp</code> <p>Ganho do controlador Proporcional.</p> <code>1.0</code> Return <p>None</p> Source code in <code>labvirtual/simulador_aeropendulo/implementacao_controlador.py</code> <pre><code>def controle_proporcional(self, kp=1.0):\n\"\"\"\n        M\u00e9todo que implementa o controle Proporcional discretizado.\n    Args:\n        kp: Ganho do controlador Proporcional.\n    Return:\n        None\n    \"\"\"\n    self.ek = self.r - self.yout\n    self.KP = kp\n    self.uk = self.KP * self.ek\n</code></pre>"}]}